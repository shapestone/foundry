package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/shapestone/foundry/internal/templating"
)

// TemplateIntegration bridges the new template system with existing generator
type TemplateIntegration struct {
	templateManager templating.TemplateManager
	fileGenerator   *FileGenerator
}

// NewTemplateIntegration creates a new template integration
func NewTemplateIntegration() *TemplateIntegration {
	// Get the directory where the foundry binary is located
	execPath, err := os.Executable()
	if err != nil {
		// Fallback to current working directory
		execPath = "."
	}
	foundryDir := filepath.Dir(execPath)
	templateDir := filepath.Join(foundryDir, "templates")

	// Create a proper config with absolute template path
	config := &templating.TemplateConfig{
		TemplateDir:        templateDir, // Absolute path to templates
		FallbackToEmbedded: true,        // Enable fallback to embedded templates
		EnableCaching:      true,        // Enable template caching
		CustomTemplateDir:  "",          // No custom template dir for now
	}

	return &TemplateIntegration{
		templateManager: templating.NewDefaultTemplateManager(config),
		fileGenerator:   NewFileGenerator(),
	}
}

// GenerateProject creates a project using the new template system
func (ti *TemplateIntegration) GenerateProject(projectPath, layoutName string, data map[string]interface{}) error {
	// Create template data
	templateData := templating.TemplateData(data)

	// Extract project name from data for cmd directory
	projectName := ""
	if name, ok := data["ProjectName"]; ok {
		if nameStr, ok := name.(string); ok {
			projectName = nameStr
		}
	}

	// List of project templates to generate
	projectTemplates := []string{"main.go", "go.mod", "README.md", "gitignore", "foundry.yaml"}

	for _, templateName := range projectTemplates {
		content, err := ti.templateManager.LoadAndRender(layoutName, "project", templateName, templateData)
		if err != nil {
			return fmt.Errorf("failed to render %s: %w", templateName, err)
		}

		// Determine output filename with project name context
		filename := ti.resolveProjectFileName(templateName, projectName)
		outputPath := filepath.Join(projectPath, filename)

		// Ensure directory exists and write file
		if err := ti.writeFile(outputPath, content); err != nil {
			return fmt.Errorf("failed to write %s: %w", filename, err)
		}
	}

	return nil
}

// GenerateComponent creates a component using the new template system
func (ti *TemplateIntegration) GenerateComponent(projectPath, componentType, componentName, layoutName string, data map[string]interface{}) error {
	// Create template data
	templateData := templating.TemplateData(data)

	// Template name should NOT include .go.tmpl extension
	// The loader will add .tmpl automatically
	templateName := componentType + ".go"

	// Render the component template
	content, err := ti.templateManager.LoadAndRender(layoutName, "components", templateName, templateData)
	if err != nil {
		return fmt.Errorf("failed to render component %s: %w", componentType, err)
	}

	// Determine output path for component
	filename := ti.resolveComponentFileName(componentType, componentName)
	outputPath := filepath.Join(projectPath, ti.getComponentDirectory(componentType, layoutName), filename)

	// Write the component file
	if err := ti.writeFile(outputPath, content); err != nil {
		return fmt.Errorf("failed to write component %s: %w", componentName, err)
	}

	return nil
}

// ValidateTemplate validates a template file
func (ti *TemplateIntegration) ValidateTemplate(layoutName, category, templateName string) error {
	// Try to get the template - if it loads without error, it's valid
	_, err := ti.templateManager.GetTemplate(layoutName, category, templateName)
	return err
}

// ListAvailableTemplates returns available templates for a layout
func (ti *TemplateIntegration) ListAvailableTemplates(layoutName string) ([]string, error) {
	// This would need to be implemented based on the template loading system
	// For now, return common template types
	return []string{"main.go", "go.mod", "README.md", "handler", "model", "middleware", "service"}, nil
}

// ClearTemplateCache clears the template cache
func (ti *TemplateIntegration) ClearTemplateCache() {
	ti.templateManager.ClearCache()
}

// GenerateProjectWithNewSystem generates project using new template system
func (ti *TemplateIntegration) GenerateProjectWithNewSystem(projectName, modulePath, outputPath string) error {
	// Detect or use default layout
	layoutName := ti.detectProjectLayout(outputPath)
	if layoutName == "" {
		layoutName = "standard" // default layout
	}

	// Prepare template data
	templateData := map[string]interface{}{
		"ProjectName": projectName,
		"ModulePath":  modulePath,
		"Author":      "Generated by Foundry",
		"License":     "MIT",
		"GoVersion":   "1.21",
		"Description": fmt.Sprintf("A Go project generated by Foundry: %s", projectName),
	}

	return ti.GenerateProject(outputPath, layoutName, templateData)
}

// GenerateComponentWithNewSystem generates component using new template system
func (ti *TemplateIntegration) GenerateComponentWithNewSystem(componentType, componentName, outputPath string) error {
	// Detect project layout
	layoutName := ti.detectProjectLayout(outputPath)
	if layoutName == "" {
		layoutName = "standard" // default layout
	}

	// Prepare component data with proper variable mapping for external templates
	templateData := map[string]interface{}{
		// Legacy variables (for backward compatibility)
		"ComponentName": componentName,
		"ComponentType": componentType,
		"PackageName":   ti.inferPackageName(outputPath, componentType),

		// External template variables - UNIVERSAL for all templates
		"ModelName":          ti.toPascalCase(componentName),              // Product, User
		"HandlerName":        ti.toPascalCase(componentName),              // Product, User (same as ModelName)
		"MiddlewareName":     ti.toPascalCase(componentName),              // Product, User (same as ModelName)
		"ServiceName":        ti.toPascalCase(componentName),              // Product, User (same as ModelName)
		"ResourceName":       ti.toCamelCase(componentName),               // product, user
		"ResourceNamePlural": ti.pluralize(ti.toCamelCase(componentName)), // products, users
		"ResourcePath":       ti.pluralize(ti.toCamelCase(componentName)), // products, users (URL path)
	}

	return ti.GenerateComponent(outputPath, componentType, componentName, layoutName, templateData)
}

// Helper methods

// resolveProjectFileName converts template name to actual filename
func (ti *TemplateIntegration) resolveProjectFileName(templateName, projectName string) string {
	switch templateName {
	case "main.go":
		return filepath.Join("cmd", projectName, "main.go")
	case "gitignore":
		return ".gitignore"
	case "foundry.yaml":
		return ".foundry.yaml"
	default:
		return templateName
	}
}

// resolveComponentFileName creates filename for component
func (ti *TemplateIntegration) resolveComponentFileName(componentType, componentName string) string {
	return fmt.Sprintf("%s_%s.go", ti.toSnakeCase(componentName), componentType)
}

// getComponentDirectory returns the directory for a component type
func (ti *TemplateIntegration) getComponentDirectory(componentType, layoutName string) string {
	switch componentType {
	case "handler":
		return "handlers"
	case "model":
		return "models"
	case "middleware":
		return "middleware"
	case "service":
		return "services"
	default:
		return "."
	}
}

// writeFile ensures directory exists and writes content to file
func (ti *TemplateIntegration) writeFile(path, content string) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("creating directory %s: %w", dir, err)
	}

	// Write file
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing file %s: %w", path, err)
	}

	return nil
}

// detectProjectLayout attempts to determine the project layout
func (ti *TemplateIntegration) detectProjectLayout(projectPath string) string {
	// Simple heuristics for layout detection
	if ti.fileExists(filepath.Join(projectPath, "cmd")) {
		return "standard"
	}

	if ti.fileExists(filepath.Join(projectPath, "internal")) {
		return "standard"
	}

	return "standard" // default fallback
}

// inferPackageName determines the appropriate package name for a component
func (ti *TemplateIntegration) inferPackageName(projectPath, componentType string) string {
	switch componentType {
	case "handler":
		return "handlers"
	case "model":
		return "models"
	case "middleware":
		return "middleware"
	case "service":
		return "services"
	default:
		return "main"
	}
}

// toSnakeCase converts string to snake_case
func (ti *TemplateIntegration) toSnakeCase(s string) string {
	// Simple snake case conversion
	result := ""
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result += "_"
		}
		result += string(r)
	}
	return result
}

// toPascalCase converts to PascalCase (Product)
func (ti *TemplateIntegration) toPascalCase(s string) string {
	if s == "" {
		return s
	}

	// Split on common separators
	words := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || r == ' '
	})

	result := ""
	for _, word := range words {
		if len(word) > 0 {
			result += strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
		}
	}

	return result
}

// toCamelCase converts to camelCase (product)
func (ti *TemplateIntegration) toCamelCase(s string) string {
	pascal := ti.toPascalCase(s)
	if len(pascal) > 0 {
		return strings.ToLower(pascal[:1]) + pascal[1:]
	}
	return pascal
}

// pluralize adds simple pluralization
func (ti *TemplateIntegration) pluralize(s string) string {
	if s == "" {
		return s
	}

	// Simple pluralization rules
	if strings.HasSuffix(s, "y") {
		return s[:len(s)-1] + "ies"
	}
	if strings.HasSuffix(s, "s") || strings.HasSuffix(s, "sh") || strings.HasSuffix(s, "ch") || strings.HasSuffix(s, "x") || strings.HasSuffix(s, "z") {
		return s + "es"
	}

	return s + "s"
}

// fileExists checks if a file exists
func (ti *TemplateIntegration) fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}
