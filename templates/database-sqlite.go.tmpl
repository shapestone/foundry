package database

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"time"

	_ "github.com/mattn/go-sqlite3"
)

// DB wraps the SQLite connection
type DB struct {
	*sql.DB
}

// NewConnection creates a new SQLite connection
func NewConnection() (*DB, error) {
	cfg := LoadConfig()

	// Ensure directory exists
	dir := filepath.Dir(cfg.Path)
	if dir != "." && dir != "/" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return nil, fmt.Errorf("failed to create database directory: %w", err)
		}
	}

	// Open database connection
	// Add connection parameters for better performance
	dsn := fmt.Sprintf("%s?_journal_mode=WAL&_busy_timeout=5000&_synchronous=NORMAL&_cache_size=10000&_foreign_keys=ON", cfg.Path)

	db, err := sql.Open("sqlite3", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// SQLite doesn't support many concurrent connections
	// Set conservative limits
	db.SetMaxOpenConns(1)
	db.SetMaxIdleConns(1)
	db.SetConnMaxLifetime(0) // Connections don't time out

	// Test the connection
	ctx, cancel := context.WithTimeout(context.Background(), cfg.ConnectTimeout)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	// Enable foreign key constraints
	if _, err := db.ExecContext(ctx, "PRAGMA foreign_keys = ON"); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to enable foreign keys: %w", err)
	}

	return &DB{DB: db}, nil
}

// Close closes the database connection
func (db *DB) Close() error {
	return db.DB.Close()
}

// Health checks the database connection
func (db *DB) Health(ctx context.Context) error {
	return db.PingContext(ctx)
}

// Transaction executes a function within a database transaction
func (db *DB) Transaction(ctx context.Context, fn func(*sql.Tx) error) error {
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	defer func() {
		if p := recover(); p != nil {
			// Rollback on panic
			tx.Rollback()
			panic(p)
		}
	}()

	if err := fn(tx); err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("transaction failed: %v, rollback failed: %w", err, rbErr)
		}
		return err
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// QueryRowContext is a convenience wrapper that adds query logging
func (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {
	start := time.Now()
	row := db.DB.QueryRowContext(ctx, query, args...)

	if os.Getenv("DB_DEBUG") == "true" {
		fmt.Printf("[DB] Query (%v): %s\n", time.Since(start), query)
	}

	return row
}

// QueryContext is a convenience wrapper that adds query logging
func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
	start := time.Now()
	rows, err := db.DB.QueryContext(ctx, query, args...)

	if os.Getenv("DB_DEBUG") == "true" {
		fmt.Printf("[DB] Query (%v): %s\n", time.Since(start), query)
	}

	return rows, err
}

// ExecContext is a convenience wrapper that adds query logging
func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	start := time.Now()
	result, err := db.DB.ExecContext(ctx, query, args...)

	if os.Getenv("DB_DEBUG") == "true" {
		fmt.Printf("[DB] Exec (%v): %s\n", time.Since(start), query)
	}

	return result, err
}

// Migrate runs database migrations (basic implementation)
func (db *DB) Migrate(ctx context.Context) error {
	// Create migrations table if not exists
	_, err := db.ExecContext(ctx, `
		CREATE TABLE IF NOT EXISTS schema_migrations (
			version INTEGER PRIMARY KEY,
			applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		return fmt.Errorf("failed to create migrations table: %w", err)
	}

	// TODO: Implement migration logic
	// This is a placeholder for migration functionality
	// Consider using a migration library like golang-migrate/migrate

	return nil
}

// Vacuum optimizes the database file
func (db *DB) Vacuum(ctx context.Context) error {
	_, err := db.ExecContext(ctx, "VACUUM")
	return err
}

// Backup creates a backup of the database
func (db *DB) Backup(ctx context.Context, destPath string) error {
	// Ensure destination directory exists
	dir := filepath.Dir(destPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create backup directory: %w", err)
	}

	// Use SQLite backup API
	query := fmt.Sprintf("VACUUM INTO '%s'", destPath)
	_, err := db.ExecContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to backup database: %w", err)
	}

	return nil
}

// GetSize returns the size of the database file in bytes
func (db *DB) GetSize() (int64, error) {
	cfg := LoadConfig()
	info, err := os.Stat(cfg.Path)
	if err != nil {
		return 0, fmt.Errorf("failed to stat database file: %w", err)
	}
	return info.Size(), nil
}